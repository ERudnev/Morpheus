// Описание технологии iQSM = "(immutable)Quantized State Model", систематизация понимания этой технологии.
// Так как iQSM развивается и была очень близкой в начале развития с достаточно известной и понятной
// концепцией ECS (Entity Component System), данный том содержит как отсылки к ECS, сравнения с ней
// и даже немного осмысления самой ECS для контекста

#include "Seed/core/FAL.tome"

namespace iQSM {

  Model: @KQM::Definition subtype of @FAL::Form {
    Clause:
      Форма, описывающая структуру моделируемой с помощью iQSM части предметной области.
      Model содержит строго определенный список типов @iQSM::Aspect, где зависимости между аспектами определены в самих аспектах.
      Model абстрагируется от конкретных типов аспектов, представляя их как гомогенный список абстрактных типов.
      Все аспекты модели образуют Direct Acyclic Graph, удовлетворяющий условию FAL::AB-BA для любой пары типов @iQSM::Aspect.
    Examples:
      "GameWorldModel", "UserManagementModel", "FinancialTransactionModel".
  }

  State: @KQM::Definition subtype of @FAL::Atom {
    Clause:
      Экземпляр состояния системы в заданный момент времени согласно определенной @iQSM::Model.
      Представляет собой полное и неизменное описание всех данных программы в конкретный момент.
      State является атомом логики программы - неделимой единицей состояния.
    Examples:
      "initialGameState", "userSessionState", "applicationStateAtTimeT".
  }

  Identifier: @KQM::Definition subtype of @FAL::MetaForm {
    Clause:
      Шаблон, определяющий типы идентификаторов для элементов системы.
      Создает пространство типов индексов, где каждый @iQSM::Aspect может иметь собственный тип идентификатора или использовать тип другого @iQSM::Aspect.
      Для каждого @iQSM::Aspect определен тип ссылки на его элементы (Aspect::Id).
      Обеспечивает гибкую систему адресации элементов без жесткой привязки к единому типу идентификатора.
    Examples:
      "User::Id", "Product::Id", "Session::Id", "Entity::Id".
  }

  Item: @KQM::Definition subtype of @FAL::MetaForm {
    Clause:
      Шаблон, создающий конкретные формы элементов данных для каждого @iQSM::Aspect.
      Для каждого @iQSM::Aspect определяет структуру его элементов (Aspect::Item).
      Item является формой данных, которая связана с конкретным аспектом предметной области.
    Examples:
      "session::Item", "user::Item", "product::Item", "character::Item".
  }

  Aspect: @KQM::Definition subtype of @FAL::Form {
    Clause:
      Форма, группирующая несколько форм и операций для одного класса сущностей предметной области.
      @iQSM::Aspect определяет полную структуру для работы с элементами определенного типа:
      - Aspect::Item - форма элементов данных аспекта
      - Aspect::Id - тип идентификаторов элементов
      - Связи с другими аспектами (с соблюдением правила AB-BA)
      - Операции и валидации для работы с элементами аспекта.
      Представляет собой единицу модульной декомпозиции системы iQSM.
    Examples:
      "UserAspect", "ProductAspect", "SessionAspect", "CharacterAspect".
  }

  Table: @KQM::Definition subtype of @FAL::MetaForm {
    Clause:
      Шаблон, создающий формы для хранения и организации элементов данных аспектов.
      Table<@iQSM::Aspect> - это форма, представляющая ассоциативный контейнер элементов Aspect::Item,
      индексированный по ключам Aspect::Id.
      Обеспечивает структурированное хранение и быстрый доступ к данным аспекта.
    Examples:
      "UserTable", "ProductTable", "SessionTable", "InventoryTable".
  }

  Functor: @KQM::Definition subtype of @FAL::Form {
    Clause:
      Форма, определяющая обобщенный тип операций над атомами состояния (@iQSM::State) в иммутабельной системе iQSM.
      Functor включает операторы (@iQSM::Operator) и валидаторы (@iQSM::Validator) -
      функции, которые принимают @iQSM::State и могут возвращать новый @iQSM::State,
      проверять существующий @iQSM::State или вычислять производные данные.
    Examples:
      "UserOperation", "DataValidator", "BusinessLogic", "ConstraintChecker".
  }

  Operator: @KQM::Definition subtype of @iQSM::Functor {
    Clause:
      Частный случай Functor - логическая или инфраструктурная операция, которая принимает текущее состояние системы (@iQSM::State)
      и возвращает новое состояние (new @iQSM::State) с результатами выполнения операции.
      Operator может быть привязан к конкретному аспекту или работать на уровне всей модели.
      Любая операция, изменяющая состояние системы, в конечном итоге производит новый @iQSM::State.
    Examples:
      "CreateUser", "UpdateProduct", "ProcessOrder", "ValidateSession".
  }

  Validator: @KQM::Definition subtype of @iQSM::Functor {
    Clause:
      Частный случай @iQSM::Functor, выполняющий валидацию состояния системы.
      Validator выполняет контракт "сделать Item/Table правильным с их точки зрения":
      - Вызывается автоматически в конце логических операций (после действия операторов)
      - Не предназначен для ручного вызова
      - Максимально атомарен и не знает о других валидаторах
      - Может противоречить другим валидаторам (противоречия разрешаются на уровне стратегии валидации).
    Examples:
      "DataIntegrityValidator", "BusinessRuleValidator", "ConstraintValidator", "FormatValidator".
  }

  StructuralValidator: @KQM::Definition subtype of @iQSM::Validator {
    Clause:
      Частный случай @iQSM::Validator, поддерживающий структурные правила модели.
      StructuralValidator проверяет соответствие структуры состояния определениям аспектов модели.
      Выводится автоматически из определений @iQSM::Aspect в модели.
    Examples:
      "AnchorIsActive", "PArentEntityIsAlive"
  }

  StateHolder: @KQM::Definition subtype of @FAL::MetaForm {
    Clause:
      Семейство классов мутабельных объектов для временного хранения состояний @iQSM::Model или ее частей.
      реализации StateHolder служат инфраструктурным мостом между мутабельными языками программирования
      и иммутабельной логикой iQSM. Не являются частью модели, но работает рядом с ней.
      Используются для группировки изменений, хранения истории состояний и других инфраструктурных задач.
    Examples:
      "TransactionState", "SessionHolder", "ModelHistory", "ChangeAccumulator".
  }

  Basis: @KQM::Definition {
    Clause:
      Базис модели - полный и единственный набор всех @iQSM::Aspect, доступных данной @iQSM::Model.
      Basis представляет собой исчерпывающий каталог аспектов, форм и операций конкретной модели.
      Валидный Basis всегда образует Directed Acyclic Graph (DAG) - ациклический граф Аспектов модели.
      Служит фундаментальной основой для реализации мета-информации и структурного анализа модели.
    Examples:
      "UserManagementBasis", "GameWorldBasis", "FinancialModelBasis".
  }

  Change: @KQM::Definition subtype of @FAL::Form {
    Clause:
      Форма, атомы которой описывают изменения между состояниями @iQSM::State.
      Change представляет собой структурированное описание модификаций, произошедших при переходе от одного состояния к другому.
      @iQSM::Functor может возвращать Change как результат своей работы для композиции операций.
    Examples:
      "StateTransition", "DataModification", "EntityUpdate".
  }

  Resource: @KQM::Definition subtype of @FAL::MetaForm {
    Clause:
      Метаформа для работы с данными, находящимися вне @iQSM::Model.
      Для внешнего типа SomeType создается аспект SomeTypeResource с SomeTypeResource::Id для идентификации
      и SomeTypeResource::Item для хранения метаданных. Само тело данных управляется внешним ResourceManager.
      Обеспечивает контролируемый доступ к мутабельным ресурсам без нарушения иммутабельности модели.
    Examples:
      "FileResource", "DatabaseConnection", "ExternalService", "TextureResource".
  }

  fal_unifies_oop_and_ecs: @KQM::Statement {
    Q: 0.85
    Core:
      The Form-Atom language &FAL can describe OOP, ECS, and iQSM uniformly.
      Paradigm-specific terms become projections of the same structure.
    Reason: A common language reduces accidental complexity between architectural models.
  }

  iQSM_looks_as_repository: @KQM::Statement {
    Q: 0.3 // illustrative analogy
    Core:
      Иногда iQSM и работу с ним можно рассматривать как работу с "репозиторием состояний системы".
      Многие термины и концепции iQSM имеют аналогии с системами управления версиями.
    Reason:
      Такие аналогии помогают лучше понять иммутабельную природу iQSM и обьяснить ее
  }

  why_it_is_not_ecs: @KQM::Statement {
    Q: 0.3
    Core:
      Все три слова из Entity Component System потеряли свой смысл для iQSM:
      - "Entity" перестал быть классом в iQSM, стал признаком Аспекта - способности Атомов существовать самостоятельно
      - "Component" переосмыслен в iQSM из-за путаницы "класс-объект" и "одно состояние - множество состояний одного элемента"
      - "System" перестали быть отдельной сущностью для iQSM, растворившись среди операций, определенных в Аспектах и Аспектов, определенных для операций над другими аспектами
    Reason:
      Оставаясь близким родсвенником ECS, iQSM говорит на другом языке ради семантической строгости
  }

  immutability_of_atoms: @KQM::Statement {
    Q: 0.95
    Core: Атомы (Item) iQSM и сам ее State иммутабельны
    Reason: иммутабельность введена в iQSM как выбранный механизм операций с состояниями
  }

  immutability_is_conceptual: @KQM::Statement {
    Q: 0.9
    Core:
      Иммутабельность State — это концептуальный инвариант, гарантирующий отсутствие side effects и чистоту операций.
      Физическая реализация может использовать sharing (например, структурное sharing в persistent data structures) для минимизации копирования.
      State — это логический снимок, а не физическая копия данных; изменения затрагивают только измененные части.
    Reason:
      Устраняет страх overhead: иммутабельность — не про копирование всего, а про неизменность прошлого состояния.
      Позволяет ветвление и concurrency без race conditions, сохраняя эффективность.
  }

  runtime_cycles_allowed: @KQM::Statement {
    Q: 0.9
    Core:
      По правилам iQSM циклы между типами Aspect'ов недопустимы. Атомы же (Item) в State могут свободно ссылаться друг на друга циклически.
      Например, Aspect A может ссылаться на Aspect B (A → B), но не наоборот (нет B → A)
      При этом Item из A и Item из B могут иметь взаимные ссылки черед идентификаторы (экземпляров) друг друга
    Reason:
      Помогает избежать взаимных зависимостей между типами, не ограничивая связи между объектами
  }

  aspect_identifier_mapping: @KQM::Statement {
    Q: 0.9
    Core:
      Каждый @Aspect имеет единственный определенный для него тип @Identifier.
      Не каждый тип @Identifier имеет единственный @Aspect - один тип идентификатора может использоваться несколькими аспектами.
      Это отношение является сюръекцией: аспекты → типы идентификаторов.
    Reason:
      Использовано как механизм ухода от Entities к "классическим" ECS: Аспекты со "своим родным" Id эквивалентны ECS::Entity,
      Аспекты "пользующиеся чужими" типами идентификаторов - аналог ECS::Component
  }

  state_is_light_weight: @KQM::Statement {
    Q: 0.6 // пояснение
    Core:
      На уровне концепции "Стейт это состояние системы". Реализация сильно оптимизирует и копирование
      и создание нового стейта из старого.
    Reason:
      Иммутабельные State часто реализуются через структурное разделение; это качественно снижает
      накладные расходы по сравнению с полным копированием
  }

  model_state_dualism: @KQM::Statement {
    Q: 0.95
    Core: Пара Модель-Стейт является проявлением &FAL::ForAtomDualism. Можно говорить о "стейтах модели"
    Reason: удобная терминология
  }

  item_is_not_an_object: @KQM::Statement {
    Q: 0.8
    Core:
      Item это лишь одно из состояний. Если попытаться найти в iQSM аналог Объекта в ООП,
      это это будет совокупность всех известных @Item с одинаковым Id среди всех State Модели.
      Концептуально - Объекты в iQSM есть, но размазаны по всем известным состояниям, связываясь в единое
      целое через общее значение Id
    Reason:
      что бы объяснить похо владющему концептом "иммутабельность" программисту "где же у на объекты?" приходится
      рассказывать, что "объект это сумма всех иммутабельных состояний. Именно по-этому и нет смысла в указателях на обьекты
  }

  state_is_like_an_item: @KQM::Statement {
    Q: 0.8
    Core:
      Аналогично &ItemIsNotAnObject State есть Атом, единичное состояние Программы.
      Аналогично набору Item с равными значениями Id, множество State "записывает" эволюцию состояния снепшотами
      Совсем не обязательно считать эволюцию "линией" это может быть более сложная структура
    Reason:
      улучшает понимание иммутабельных особенностей iQSM
  }

  aspect_name_matters: @KQM::Statement {
    Q: 0.2
    Core:
      Каждый Аспект (как Форма и структура Форм) имеет имя (строка) которое очень
      удобно для связывания между формами разных уровней (Аспект имеет подтипы)
    Reason:
      По смыслу, Апект это скорее пространство имен, но в С++ реализации очень удобно ситать типом и использовать как параметр шаблонов:
      - template<Aspect X> get_item()-> typename X::Item
      - template<Aspect X> struct Table<X> {...} ~= continer<X::Id, X::Item>
  }

  own_identifier_means: @KQM::Statement {
    Q: 0.85
    Core:
      Item тех Аспектов, где свой Id определен - могут существовать самостоятельно
      Item тех Аспектов, где как Id использован "чужой" тип, жизненный цикл
      "привязывается" к Item того типа (Аспекта), чем тип Id использован
    Reason:
      Обобщение ECS Entity, как "контролера жизненного цикла компонент" на "Аспект с собственным типом Id"
      Принцип "эти объекты самостоятельны, а другие - их опциональные логические части"
  }

  functor_looks_better_with_table: @KQM::Statement {
    Q: 0.5
    Core: удобнее определять конкретные Функторы как Атомы некоей Формы "операций над Table"
    Reason: Реализация сильно проще
  }

  validation: @KQM::Statement {
    Q: 0.9
    Core:
      Название для процесса применения всех доступных Валидаторов над State (по частям)
      Validation(State) -> State
    Reason:
      Множество Валидаторов имеет смысл рассматривать как части некоего единого процесса, обеспечивающего корректность состояний Модели
  }

  validation_is_subjective: @KQM::Statement {
    Q: 0.9
    Core:
      Элемент Aspect<A>::Item валидный с точки зрения критериев Aspect<A>::Validation, может считаться невалидным
      с точки зрения Aspect<B>::Validation при чем из &FAL::AB-BA следует что раз B меет "точку зрения про A"
      значит Aspect<A> вообще не знает о существовании Aspect<B>
    Reason:
      Валидность зависит от контекста, плная валидность для всех Table Стейта может быть достигнута валидацией
      по дереву зависимостей внутри полного DAG Аспектов (как типов)
  }

  why_functor_application_can_create_state: @KQM::Statement {
    Q: 0.1 // обьяснение
    Core:
      В общем случае, применение Функтора может создавать новый Стейт
    Reason:
      Измененный Item не запишешь в Table - он иммутабельный, надо создать новый..
      Table, но его не запишешь в State - он иммутабельный, надо создать новый...
      State, и его уже можно где-то запомнить в StateHolder или передать как аргумент...
      следующему оператору
  }

  why_functor_application_can_skip_creating_state: @KQM::Statement {
    Q: 0.1 // обьяснение
    Core:
      В общем случае, применение Функтора может не создавать новый Стейт:
      - функтор может быть изначально "чисто для чтения либо рассчетов" ("константный")
      - функтор мжет иметь роль "менять что-то" но при конкретном вызове "не захотеть"
    Reason:
      Если Оператор ничего не поменял, то и Стейт создавать не надо.
      Когда Валидаторы молчат и ничего не трогают, так и незачем плодить Стейты.
      Оптимизация.
  }

  time_not_matters: @KQM::Statement {
    Q: 0.2
    Core:
      State may be interpreted as a snapshot; mapping to time is optional and external to the model
    Reason:
      Можно иметь несколько конкурирующих "веток" и смержить их когда надо.
      Можно выбрамывать все состояния, оставляя одно "текущее". Выбор за архитектором конкретной системы.
  }

  strong_typed_origin: @KQM::Statement {
    Q: 0.2
    Core:
      Концепция iQSM по своей природе не зависит от языка программирования.
      Однако она использует строгую типизацию, естественную для языков проде С++
    Reason:
      Это объясняет акцент на строгой типизации, одновременно признавая более широкую применимость концепции.
  }

  system_is_state_centric: @KQM::Statement {
    Q: 0.9
    Core:
      iQSM организована вокруг явных состояний мира.
      Состояние является значением первого класса и представляет полный снимок.
    Reason:
      Это устанавливает состояние как первичный носитель смысла и времени.
  }

  state_is_immutable: @KQM::Statement {
    Q: 0.5
    Core:
      Любое изменение производит новое состояние.
      Предыдущие состояния никогда не мутируют.
    Reason:
      Неизменяемость устраняет скрытые побочные эффекты и позволяет ветвление.
  }

  no_central_entity: @KQM::Statement {
    Q: 0.5
    Core:
      Не существует универсального якоря Entity.
      Идентичность не сводится к единому корневому идентификатору.
    Reason:
      Это устраняет онтологическое узкое место классического ECS.
  }

  elements_are_independent: @KQM::Statement {
    Q: 0.85
    Core:
      Некоторые элементы существуют независимо со своей собственной идентичностью.
      Они не прикреплены к родительской сущности.
    Reason:
      Это позволяет создавать более богатые графы идентичности, чем плоские модели сущность-компонент.
  }

  operations_are_external: @KQM::Statement {
    Q: 0.95
    Core: Операции не принадлежат данным. Они преобразуют состояние извне.
    Reason: Разделение структуры и поведения сохраняет архитектурную ясность.
  }

  operations_produce_states: @KQM::Statement {
    Q: 0.95
    Core: Операция отображает одно состояние в другое. Результатом является новое состояние.
    Reason: Это делает временную эволюцию явной и поддающейся инспекции.
  }

  validation_is_separated: @KQM::Statement {
    Q: 0.9
    Core:
      Валидация не смешивается с логикой трансформации.
      Нормализация и проверки целостности являются отдельными шагами.
    Reason:
      Не будь Валидация отдельным и обязательным шагом в конце любой операции,
      мы бы получали промежуточные невалидные стейты, которые просто нет смысла делать стабильными
  }

  type_graph_is_acyclic: @KQM::Statement {
    Q: 0.95
    Core: By construction, the type dependency graph is acyclic within the modeling rules.
    Reason: Ацикличность графа типов используется как средство повышения модульности
  }

  structural_decomposition_by_dag: @KQM::Statement {
    Q: 0.9
    Core:
      Система может быть разрезана вдоль DAG типов.
      Частичные представления остаются структурно валидными.
    Reason:
      Структура DAG обеспечивает безопасное извлечение подсистем.
  }

  reading_is_pure: @KQM::Statement {
    Q: 0.95
    Core:
      Операции чтения не модифицируют состояние.
      Они наблюдают только существующую структуру.
    Reason:
      Чистота гарантирует референциальную прозрачность для запросов.
  }

  writing_is_explicit: @KQM::Statement {
    Q: 0.95
    Core:
      Операции записи являются явными трансформациями.
      Скрытые мутации не существуют.
    Reason:
      Явные записи делают распространение изменений анализируемым.
  }

  time_is_modeled_by_states: @KQM::Statement {
    Q: 0.9
    Core:
      Время представляется как последовательность состояний.
      Не существует неявного временного измерения.
    Reason:
      Временное рассуждение возникает из последовательности состояний.
  }

  system_is_language_for_structure: @KQM::Statement {
    Q: 0.85
    Core:
      iQSM выступает как декларативный язык для структуры.
      Он описывает что существует, а не как это исполняется.
    Reason:
      Это согласовывает систему с архитектурным и когнитивным моделированием.
  }


