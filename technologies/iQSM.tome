// Описание технологии iQSM = "(immutable)Quantized State Model", систематизация понимания этой технологии.
// Так как iQSM развивается и была очень близкой в начале развития с достаточно известной и понятной
// концепцией ECS (Entity Component System), данный том содержит как отсылки к ECS, сравнения с ней
// и даже немного осмысления самой ECS для контекста

#using namespace FAL(file: "core/FAL.tome")
#using namespace KQM(file: "core/KQM.tome")
#using namespace FTA(file: "core/FTA.tome")

namespace iQSM {

  //// PROCESSED PART

  Aspect: @Definition {
    Clause:
      Aspect — именованный якорь типовой системы iQSM.
      Главный смысл аспекта — быть именем/ID предметной сущности (в духе ECS: "entity как id"),
      к которому затем привязываются формы данных, операции и инварианты этой сущности.

      Aspect используется как параметр для инстанцирования связанных форм (например, "поле A", "Id(A)", "Item(A)").
  
      Важно: аспект не описывает совокупность аспектов как целое и не содержит глобальные отношения между ними.
      Это делает Schema.
    Notation:
      <aspect_name>: @Aspect
    Examples:
      "Elephant: @Aspect", "physics_Position: @Aspect", "Tetris_gameplay_UserStats: @Aspect"
  }

  Identifier: @Definition(@Template(@Aspect)) {
    Clause:
      Identifier — шаблон, задающий форму идентификатора элементов, связанных с данным @Aspect.
      Identifier используется для identity элементов полей и элементов совокупностей изменений (DeltaTotality).

      Важно: на уровне Schema идентификатором аспекта является его имя (сам @Aspect-атом).
    Examples:
      "Identifier<Elephant>", "Identifier<physics_Position>", "Identifier<Tetris_gameplay_UserStats>"
  }

  Schema: @Definition(@Container(@Aspect)) {
    Clause:
      Schema является полным и единственным набором всех объявленных аспектов данной системы.
      Схема задаёт совокупность аспектов и свойства целого:
      - отношения между аспектами как типами (зависимости, DAG)
      - метаданные совокупности: индексы/поиск по аспектам, цепочки зависимостей,
        технические конструкторы/производные структуры, нужные для работы с аспектами

      Якорь к аспектам: Schema не "определяет смысл" аспектов, а собирает уже определённые аспекты в одно целое
      и фиксирует отношения между ними как свойства совокупности.
    Examples:
      "GameWorldSchema", "UserManagementSchema", "FinancialTransactionSchema".
  }

  Model: @Definition(@Form) {
    Clause:
      Model — абстракция над множеством состояний (State), соответствующих схеме (@Schema).
      Модель скрывает детали хранения и может содержать одно или множество состояний,
      предоставляя интерфейс работы с состояниями и переходами (Diff) / изменениями (DeltaTotality).
      Model не является состоянием и не является схемой: это уровень абстракции между ними.
      Для Модели подразумевается мутабельный интерфейс
    Examples:
      "GameWorldModel", "UserManagementModel", "FinancialTransactionModel".
  }

  Quantum: @Definition(@Template(@Aspect)) {
    Clause:
      Квант — типовая форма, связанная с @Aspect 
      Квант не является сущностью и не обладает онтологией: он фиксирует лишь "как устроены данные", а не "чем они являются".
      Квант определяет:
      - структурную форму данных (shape)
      - размерность/кардинальность
      - допустимые операции над значением
      - алгебраическую природу значения
      Квант используется как форма состояния и как форма изменения (дифференциала).
    Examples:
      "Quantum<MyAspect>", Quantum"
  }

  Particle: @Definition(@Template(@Aspect)) {
    Clause:
      Партикль — онтологический элемент поля: элемент совокупности Field(@A) для некоторого @Aspect A.
      Партикль:
      - имеет identity, задаваемую Identifier(@A)
      - существует в рамках конкретного поля Field(@A)
      - несёт значение в квантовой форме Quantum(@A) (форма хранения/переноса значения)

      Концептуально: Particle(@A) = Quantum(@A) + онтологическая интерпретация "элемент поля".
    Examples:
      "Particle<Elephant>", "Particle<physics_Position>"
  }

  Xion: @Definition(@Particle) {
    Clause:
      Xion — самостоятельный партикль: имеет право на существование независимо от других полей.
      В проекции iQSM это соответствует аспектам с "собственным" Identifier(@A).
    Examples:
      "Xion<User>", "Xion<Order>".
  }

  Quark: @Definition(@Particle) {
    Clause:
      Quark — несамостоятельный партикль: существует только в контексте ксионного поля.
      В проекции iQSM это соответствует аспектам, использующим чужой тип идентификатора
      (жизненный цикл привязан к Xion по Id).
    Examples:
      "UserProfile (uses User_Id)", "Inventory (uses Character_Id)".
  }

  Field: @Definition(@Template(@Aspect)) {
    Clause:
      Поле — совокупность партиклей данного @Aspect, рассматриваемая как одно целое.
      Поле не является типом данных и не является контейнером в объектно-ориентированном смысле.
      Поле — гомогенная совокупность партиклей, над которой действуют общие законы,
      использующая квант (Quantum) как форму представления своих элементов.
      В iQSM поле обычно реализуется как ассоциативное хранилище партиклей по идентификаторам.
    Examples:
      "Field<User>", "Field<physics_Position>", "Field<Inventory>".
  }


  //// UNPROCESSED PART BELOW

  Item: @Definition(@Template(@Aspect)) {
    Clause:
      Шаблон, создающий конкретные формы элементов данных для каждого @Aspect.
      Для каждого @Aspect определяет форму значений этого аспекта (Aspect_Item).
    Examples:
      "Item<Elephant>", "Item<physics_Position>", "Item<Tetris_gameplay_UserStats>"
  }

  Functor: @Definition(@Form) {
    Clause:
      Форма, определяющая обобщенный тип операций над атомами состояния (@State) в иммутабельной системе iQSM.
      Functor включает операторы (@Operator) и валидаторы (@Validator) -
      функции, которые принимают @State и могут возвращать новый @State,
      проверять существующий @State или вычислять производные данные.
    Examples:
      "UserOperation", "DataValidator", "BusinessLogic", "ConstraintChecker".
  }

  Operator: @Definition(@Subtype(@Functor)) {
    Clause:
      Частный случай Functor — логическая или инфраструктурная операция, которая задаёт переход (Diff)
      от текущего состояния системы (@State) к новому состоянию (new @State).
      Operator может быть привязан к конкретному аспекту или работать на уровне всей модели.
      Любая операция, изменяющая состояние системы, в конечном итоге производит новый @State.
    Examples:
      "CreateUser", "UpdateProduct", "ProcessOrder", "ValidateSession".
  }

  Validator: @Definition(@Subtype(@Functor)) {
    Clause:
      Частный случай @Functor, выполняющий валидацию состояния системы.
      Validator выполняет контракт "сделать Item/Field правильным с их точки зрения":
      - Вызывается автоматически в конце логических операций (после действия операторов)
      - Не предназначен для ручного вызова
      - Максимально атомарен и не знает о других валидаторах
      - Может противоречить другим валидаторам (противоречия разрешаются на уровне стратегии валидации).
    Examples:
      "DataIntegrityValidator", "BusinessRuleValidator", "ConstraintValidator", "FormatValidator".
  }

  StructuralValidator: @Definition(@Subtype(@Validator)) {
    Clause:
      Частный случай @Validator, поддерживающий структурные правила схемы (Schema).
      StructuralValidator проверяет соответствие структуры состояния (State) определениям аспектов схемы.
      Выводится автоматически из определений @Aspect в @Schema.
    Examples:
      "AnchorIsActive", "PArentEntityIsAlive"
  }

  Resource: @Definition(@Template(@Form)) {
    Clause:
      Шаблон для работы с данными, находящимися вне моделируемого пространства iQSM
      (вне @Schema и вне полей состояния).
      Для внешнего типа SomeType создается аспект SomeTypeResource с SomeTypeResource_Id для идентификации
      и SomeTypeResource_Item для хранения метаданных. Само тело данных управляется внешним ResourceManager.
      Обеспечивает контролируемый доступ к мутабельным ресурсам без нарушения иммутабельности модели.
    Examples:
      "FileResource", "DatabaseConnection", "ExternalService", "TextureResource".
  }

  Diff: @Definition(@Atom) {
    Clause:
      Diff — оператор перехода между состояниями (State).
      Diff — это морфизм: State -> State.
      Внутреннее представление Diff может включать:
      - before / after (пары квантов)
      - и/или DeltaTotality как "слой изменений"
      При этом слой изменений является представлением оператора, а не самостоятельным полем.
    Examples:
      "ApplyOperationDiff", "MergeBranchDiff".
  }

  hierarchy_summary: @Statement(~0.8) {
    Core:
      Краткая онтологическая и типовая иерархия:
      - Quantum — форма
      - Particle — онтология формы
      - Field — тоталити партиклей
      - Totality — квантор совокупности
      - Aspect — атомарный тип поля
      - Schema — совокупность аспектов (тип модели)
      - Model — абстракция над состояниями и переходами
      - State — состояние мира
      - DeltaTotality — изменение мира
      - Diff — оператор перехода
    Reason:
      Фиксирует термины и предотвращает смешение уровней "форма/онтология/оператор".
  }

  fixation_is_incremental: @Statement(~0.6) {
    Core:
      Эта фиксация не закрывает систему полностью: она встраивает уточнённые смыслы в существующее описание,
      не ломая его и не подменяя.
    Reason:
      Терминология должна эволюционировать без переписывания всей модели в каждом тексте.
  }

  State: @Definition(@Atom) {
    Clause:
      State — тоталити партиклей, представляющая состояние мира.
      Это "снимок" всех полей (Field) в рамках одной схемы (Schema).
      State гомогенен по принципу тоталити: на этом уровне важно "всё как одно",
      а не внутренние различия между аспектами.
    Examples:
      "initialGameState", "userSessionState", "applicationStateAtTimeT".
  }

  item_is_quantum_projection: @Statement(~0.8) {
    Core:
      В проекции iQSM квант (Quantum) аспектного поля выражается как Aspect_Item:
      это типовая форма значения партикля (Particle) в данном поле.
    Reason:
      Связывает новую терминологию Quantum/Particle/Field с существующими конструкциями Item/Field.
  }

  fal_unifies_oop_and_ecs: @Statement(~0.85) {
    Core:
      The Form-Atom language &FAL can describe OOP, ECS, and iQSM uniformly.
      Paradigm-specific terms become projections of the same structure.
    Reason: A common language reduces accidental complexity between architectural models.
  }

  iQSM_looks_as_repository: @Statement(~0.3) { // illustrative analogy
    Core:
      Иногда iQSM и работу с ним можно рассматривать как работу с "репозиторием состояний системы".
      Многие термины и концепции iQSM имеют аналогии с системами управления версиями.
    Reason:
      Такие аналогии помогают лучше понять иммутабельную природу iQSM и объяснить её:
      состояния похожи на снапшоты/коммиты, а Diff — на осмысленный переход между ними.
  }

  why_it_is_not_ecs: @Statement(~0.3) {
    Core:
      Все три слова из Entity Component System потеряли свой смысл для iQSM:
      - "Entity" не является центральным объектом: самостоятельность выражается через Xion (аспект с собственным Id)
      - "Component" не является "частью объекта": зависимая часть выражается через Quark (аспект, использующий чужой Id)
      - "System" не является отдельной сущностью: поведение выражается как внешние операции, задающие Diff между состояниями
    Reason:
      Оставаясь близким родственником ECS, iQSM говорит на другом языке ради семантической строгости.
  }

  immutability_of_atoms: @Statement(~0.95) {
    Core:
      Партикли (Particle; в проекции iQSM — значения Aspect_Item) и состояния (State) иммутабельны.
    Reason: иммутабельность введена в iQSM как выбранный механизм операций с состояниями
  }

  immutability_is_conceptual: @Statement(~0.9) {
    Core:
      Иммутабельность State — это концептуальный инвариант, гарантирующий отсутствие side effects и чистоту операций.
      Физическая реализация может использовать sharing (например, структурное sharing в persistent data structures) для минимизации копирования.
      State — это логический снимок, а не физическая копия данных; изменения затрагивают только измененные части.
    Reason:
      Устраняет страх overhead: иммутабельность — не про копирование всего, а про неизменность прошлого состояния.
      Позволяет ветвление и concurrency без race conditions, сохраняя эффективность.
  }

  runtime_cycles_allowed: @Statement(~0.9) {
    Core:
      По правилам iQSM циклы между типами Aspect'ов недопустимы. Партикли (Aspect_Item/Particle) в State
      могут свободно ссылаться друг на друга циклически.
      Например, Aspect A может ссылаться на Aspect B (A → B), но не наоборот (нет B → A)
      При этом Item из A и Item из B могут иметь взаимные ссылки через идентификаторы (экземпляров) друг друга
    Reason:
      Помогает избежать взаимных зависимостей между типами, не ограничивая связи между объектами
  }

  aspect_identifier_mapping: @Statement(~0.9) {
    Core:
      Каждый @Aspect имеет единственный определенный для него тип @Identifier.
      Не каждый тип @Identifier имеет единственный @Aspect - один тип идентификатора может использоваться несколькими аспектами.
      Это отношение является сюръекцией: аспекты → типы идентификаторов.
    Reason:
      Это используется как механизм выражения онтологии самостоятельности:
      - аспект со "своим родным" Id соответствует Xion
      - аспект, "пользующийся чужим" типом идентификатора, соответствует Quark
  }

  state_is_light_weight: @Statement(~0.6) { // пояснение
    Core:
      На уровне концепции "Стейт это состояние системы". Реализация сильно оптимизирует и копирование
      и создание нового стейта из старого.
    Reason:
      Иммутабельные State часто реализуются через структурное разделение; это качественно снижает
      накладные расходы по сравнению с полным копированием
  }

  model_state_dualism: @Statement(~0.95) {
    Core:
      Пара Schema–State (и исторически Model–State) является проявлением &form-atom_dualism:
      схема задаёт типовое пространство возможных состояний, а состояние — конкретный атом в этом пространстве.
    Reason: удобная терминология
  }

  item_is_not_an_object: @Statement(~0.8) {
    Core:
      Particle (в проекции iQSM — значение Aspect_Item) — это лишь одно из состояний некоторой "вещи".
      Если попытаться найти аналог объекта ООП, то им будет совокупность всех известных Item с одинаковым Id
      среди всех состояний (State) модели.
      Концептуально "объекты" в iQSM существуют, но распределены по истории состояний и собираются по identity (Id).
    Reason:
      Чтобы объяснить плохо владеющему концептом иммутабельности программисту "где же у нас объекты?",
      приходится говорить: объект — это сумма (или траектория) всех иммутабельных состояний, связанных общим Id.
  }

  state_is_like_an_item: @Statement(~0.8) {
    Core:
      Аналогично &item_is_not_an_object, State — это атом, единичное состояние программы.
      Множество State "записывает" эволюцию состояния снапшотами; это не обязано быть линией — возможны ветки и слияния.
    Reason:
      улучшает понимание иммутабельных особенностей iQSM
  }

  aspect_name_matters: @Statement(~0.2) {
    Core:
      Каждый Аспект (как Форма и структура Форм) имеет имя (строка) которое очень
      удобно для связывания между формами разных уровней (Аспект имеет подтипы)
    Reason:
      По смыслу, Аспект — это скорее пространство имён, но в C++ реализации очень удобно считать типом и использовать как параметр шаблонов:
      - template<Aspect X> get_item() -> X.Item
      - template<Aspect X> struct FieldStorage<X> {...} ~= container<X.Id, X.Item>
  }

  own_identifier_means: @Statement(~0.85) {
    Core:
      Item тех аспектов, где определён собственный Id, могут существовать самостоятельно (Xion).
      Item тех аспектов, где в качестве Id использован "чужой" тип, онтологически являются зависимыми (Quark):
      их жизненный цикл "привязывается" к Item того аспекта, чей тип Id используется.
    Reason:
      Обобщение ECS_Entity как "контролёра жизненного цикла компонент" на "аспект с собственным типом Id".
      Принцип "эти объекты самостоятельны, а другие - их опциональные логические части"
  }

  functor_looks_better_with_table: @Statement(~0.5) {
    Core: удобнее определять конкретные Функторы как Атомы некоей Формы "операций над полями"
    Reason: Реализация сильно проще
  }

  validation: @Statement(~0.9) {
    Core:
      Название для процесса применения всех доступных валидаторов над состоянием (State) по частям:
      Validation(State) -> State.
    Reason:
      Множество валидаторов имеет смысл рассматривать как части единого процесса,
      обеспечивающего корректность состояний модели относительно её схемы.
  }

  validation_is_subjective: @Statement(~0.9) {
    Core:
      Элемент Aspect<A>.Item валидный с точки зрения критериев Aspect<A>.Validation, может считаться невалидным
      с точки зрения Aspect<B>.Validation, причём из &AB-BA следует: раз B имеет "точку зрения про A",
      значит Aspect<A> вообще не знает о существовании Aspect<B>
    Reason:
      Валидность зависит от контекста; полная валидность для всех полей состояния достигается валидацией
      по дереву зависимостей внутри полного DAG аспектов (как типов) схемы.
  }

  why_functor_application_can_create_state: @Statement(~0.1) { // объяснение
    Core:
      В общем случае применение функтора создаёт новое состояние (State).
    Reason:
      Измененный Item не запишешь в поле - он иммутабельный, надо создать новое хранилище поля.
      Хранилище поля, но его не запишешь в State - он иммутабельный, надо создать новый...
      State, и его уже можно где-то запомнить в StateHolder или передать как аргумент...
      следующему оператору
  }

  why_functor_application_can_skip_creating_state: @Statement(~0.1) { // объяснение
    Core:
      В общем случае применение функтора может не создавать новое состояние (State):
      - функтор может быть изначально "чисто для чтения либо расчётов" ("константный")
      - функтор может иметь роль "менять что-то", но при конкретном вызове "не захотеть"
    Reason:
      Если оператор ничего не поменял, то и состояние создавать не надо.
      Когда валидаторы молчат и ничего не трогают — незачем плодить состояния.
      Оптимизация.
  }

  time_not_matters: @Statement(~0.2) {
    Core:
      State may be interpreted as a snapshot; mapping to time is optional and external to the schema/model.
    Reason:
      Можно иметь несколько конкурирующих "веток" и смержить их когда надо.
      Можно выбрасывать все состояния, оставляя одно "текущее". Выбор за архитектором конкретной системы.
  }

  strong_typed_origin: @Statement(~0.2) {
    Core:
      Концепция iQSM по своей природе не зависит от языка программирования.
      Однако она использует строгую типизацию, естественную для языков вроде C++.
    Reason:
      Это объясняет акцент на строгой типизации, одновременно признавая более широкую применимость концепции.
  }

  system_is_state_centric: @Statement(~0.9) {
    Core:
      iQSM организована вокруг явных состояний мира (State).
      Состояние является значением первого класса и представляет полный снимок всех полей.
    Reason:
      Это устанавливает состояние как первичный носитель смысла и времени.
  }

  state_is_immutable: @Statement(~0.5) {
    Core:
      Любое изменение производит новое состояние.
      Предыдущие состояния никогда не мутируют.
    Reason:
      Неизменяемость устраняет скрытые побочные эффекты и позволяет ветвление.
  }

  no_central_entity: @Statement(~0.5) {
    Core:
      Не существует универсального якоря Entity.
      Идентичность не сводится к единому корневому идентификатору.
    Reason:
      Это устраняет онтологическое узкое место классического ECS.
  }

  elements_are_independent: @Statement(~0.85) {
    Core:
      Некоторые элементы существуют независимо со своей собственной идентичностью.
      Они не прикреплены к родительской сущности.
    Reason:
      Это позволяет создавать более богатые графы идентичности, чем плоские модели сущность-компонент.
  }

  operations_are_external: @Statement(~0.95) {
    Core: Операции не принадлежат данным. Они преобразуют состояние извне.
    Reason: Разделение структуры и поведения сохраняет архитектурную ясность.
  }

  operations_produce_states: @Statement(~0.95) {
    Core:
      Операция задаёт Diff (морфизм) между состояниями: она отображает одно состояние в другое.
      Результатом является новое состояние (State), а изменения могут быть представлены как DeltaTotality.
    Reason: Это делает временную эволюцию явной и поддающейся инспекции.
  }

  validation_is_separated: @Statement(~0.9) {
    Core:
      Валидация не смешивается с логикой трансформации.
      Нормализация и проверки целостности являются отдельными шагами.
    Reason:
      Не будь Валидация отдельным и обязательным шагом в конце любой операции,
      мы бы получали промежуточные невалидные стейты, которые просто нет смысла делать стабильными
  }

  type_graph_is_acyclic: @Statement(~0.95) {
    Core: By construction, the type dependency graph is acyclic within the modeling rules.
    Reason: Ацикличность графа типов используется как средство повышения модульности
  }

  structural_decomposition_by_dag: @Statement(~0.9) {
    Core:
      Система может быть разрезана вдоль DAG типов.
      Частичные представления остаются структурно валидными.
    Reason:
      Структура DAG обеспечивает безопасное извлечение подсистем.
  }

  reading_is_pure: @Statement(~0.95) {
    Core:
      Операции чтения не модифицируют состояние.
      Они наблюдают только существующую структуру.
    Reason:
      Чистота гарантирует референциальную прозрачность для запросов.
  }

  writing_is_explicit: @Statement(~0.95) {
    Core:
      Операции записи являются явными трансформациями.
      Скрытые мутации не существуют.
    Reason:
      Явные записи делают распространение изменений анализируемым.
  }

  time_is_modeled_by_states: @Statement(~0.9) {
    Core:
      Время представляется как последовательность состояний.
      Не существует неявного временного измерения.
    Reason:
      Временное рассуждение возникает из последовательности состояний.
  }

  system_is_language_for_structure: @Statement(~0.85) {
    Core:
      iQSM выступает как декларативный язык для структуры.
      Он описывает что существует, а не как это исполняется.
    Reason:
      Это согласовывает систему с архитектурным и когнитивным моделированием.
  }

}
