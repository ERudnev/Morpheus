// FAL = Form-Atom Language
// Язык описания состояния любой системы как набора Атомов разных Форм.
// Определен с целью внесения в использующих язык описаний максимальной строгости и точности
// Позволяет определить полное состояние системы как Атом более высокого уровня и говорить об операциях с ним
// Использование FAL уводит от заложенных в язык ассоциаций и аккуратно вносит нужные, что важно для работы с LLM
//
// "Законы природы ничего не знают об Английском Языке, но могут быть им описаны" (если кому-то режет глаз форма записи этого текста)

#using "KQM.tome" as semantics

namespace FAL {

  Atom: @KQM::Definition {
    Clause:
      Atom — единая неделимая адресуемая сущность своего слоя абстракции.
      Обобщает понятия "объект, реализация интерфейса, данные" как "экземпляр, инстанс, частный случай адресуемый".
    Examples:
      "john_doe_user", "app_config_v2", "text_analyzer_process", "customer_record_456", "http_client_impl"
  }

  Form: @KQM::Definition {
    Clause:
      Form — класс атомов одного слоя абстракции, задающий их структуру и допустимые связи.
      Обобщает понятия "класс, интерфейс, протокол" как "способ, рамка, договоренность".
    Examples:
      "UserAccount", "AppConfiguration", "DataProcessingTask", "CustomerRecord", "NetworkInterface"
  }

  MetaForm: @KQM::Definition subtype of @Form {
    Clause:
      MetaForm — Форма, Атомы которой сами по себе являются Формами.
      Для любого непустого множества F Форм {MyFormX, MyFormY,...} может существовать @Form MyForms,
      где каждый из F - ее @Atom.
      Верно следующее: любая МетаФорма является Формой.
    Examples:
      "EntityTypeCollection", "ProgrammingLanguageTypeSystem", "ClassGenerator", "TemplateLibrary"
  }

  fundamental_definitions: @KQM::Statement {
    Q: 0.2 // explaination
    Core:
      Пара ключевых определений тома по сути:
      - Form (Форма): что может быть
      - Atom (Атом): что есть
    Reason:
      Понимание на базовом уровне получено в рассуждениях
  }

  AB-BA: @KQM::Statement {
    Q: inf // cognitive law
    Core:
      "Если тип А знает о типе Б, то тип Б не должен даже подозревать о существовании типа А"
      Критерий AB-BA выполняется, если когнитивные связи между @Form односторонние.
      В этом случае граф всех возможных @Form будет ацикличен (Direct Acyclic Graph).
    Reason:
      Возведенная в абсолют борьба с циклическими связями между классами в архитектуре
  }

  type_vs_instance_separation: @KQM::Statement {
    Q: 0.9 // clarification
    Core:
      &AB-BA регулирует только связи между @Form (типами, классами), а не между @Atom (экземплярами, объектами).
      @Atom могут формировать любые runtime-графы, включая циклы — это не нарушает ацикличность DAG типов.
      @Form описывает структуру @Atom, но не диктует, как @Atom взаимодействуют во время исполнения.
    Reason:
      Убирает путаницу между compile-time зависимостями типов и runtime-связями экземпляров.
      В ООП аналог: классы могут иметь unidirectional зависимости (наследование), но объекты — bidirectional ссылки.
  }

  form-atom_dualism: @KQM::Statement {
    Q: 0.9 // definition linkage
    Core:
      Определения @Form и @Atom имеют смысл в паре, устанавливая отношения вида "тип-сущность"
    Reason:
      Дуализм имеет аналоги в разных предметных областях: "Класс/Объект" или "Интерфейс/Реализация" или "Шаблон/Инстанс шаблона" или "type/value"
  }

  properties_of_definitions: @KQM::Statement {
    Q: 0.8 // properties
    Core:
      Разрешена вложенность: @Atom более высокого уровня абстракции может содержать множество @Atom разных @Form более низкого уровня
      Единственность @Form: @Atom имеет одну и только одну @Form
    Reason:
      Закрепление понимания определений и выявление важнейших свойств
  }

  properties_of_AB-BA: @KQM::Statement {
    Q: 0.8 // properties
    Core:
      Правило &AB-BA не зависит от уровней системы: действует на зависимости @Form как внутри слоя, так и между слоями
      Частный случай правила: если система S знает о какой-либо своей части A, то части A запрещено знать о системе S
      DAG-тяготение: любая совокупность @Form представима в виде DAG (Directed Acyclic Graph)
      Правило Третьего: если @Atom двух различных @Form взаимно нуждаются в данных друг друга, это указывает на рождение новой @Form
    Reason:
      Обобщение практического опыта архитектуры программного обеспечения, где двусторонние зависимости приводят к росту технического долга
  }

  sometimes_forms_are_atoms: @KQM::Statement {
    Q: 0.2 // наблюдение
    Core: Формы иногда могут быть представлны как Атомы некоей МетаФормы
    Reason: Постоянно проявляется на практике как удобство: тут и там видятся мета-классы
  }
}


