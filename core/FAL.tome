// FAL = Form-Atom Language
// Язык описания состояния любой системы как набора Атомов разных Форм.
// Определен с целью внесения в использующих язык описаний максимальной строгости и точности
// Позволяет определить полное состояние системы как Атом более высокого уровня и говорить об операциях с ним
// Использование FAL уводит от заложенных в язык ассоциаций и аккуратно вносит нужные, что важно для работы с LLM
//
// "Законы природы ничего не знают об Английском Языке, но могут быть им описаны" (если кому-то режет глаз форма записи этого текста)

#using namespace KQM(file: "core/KQM.tome")

namespace FAL {

  Atom: @Definition {
    Clause:
      Atom — единая неделимая адресуемая сущность своего слоя абстракции.
      Обобщает понятия "объект, реализация интерфейса, данные" как "экземпляр, инстанс, частный случай адресуемый".
    Examples:
      "john_doe_user", "app_config_v2", "text_analyzer_process", "customer_record_456", "http_client_impl"
  }

  Form: @Definition {
    Clause:
      Form — класс атомов одного слоя абстракции, задающий их структуру и допустимые связи.
      Обобщает понятия "класс, интерфейс, протокол" как "способ, рамка, договоренность".
    Examples:
      "UserAccount", "AppConfiguration", "DataProcessingTask", "CustomerRecord", "NetworkInterface"
  }

  MetaForm: @Definition {
    Clause:
      MetaForm — @Form, чьи @Atom интерпретируются как @Form (то есть "формы как атомы мета-уровня").
      Это не @Container(@Form): MetaForm фиксирует рефикацию форм, а Container фиксирует "множество как одно".
    Examples:
      "MyTypeSystem", "MySchemaLanguage", "MyFormVocabulary", "MyClassGenerator"
  }

  AB-BA: @Statement(inf) {
    Core:
      "Если тип А знает о типе Б, то тип Б не должен даже подозревать о существовании типа А"
      Критерий AB-BA выполняется, если когнитивные связи между @Form односторонние.
      В этом случае граф всех возможных @Form будет ацикличен (Direct Acyclic Graph).
    Reason:
      Возведенная в абсолют борьба с циклическими связями между классами в архитектуре
  }

  type_vs_instance_separation: @Statement(~0.9) {
    Core:
      &AB-BA регулирует только связи между @Form (типами, классами), а не между @Atom (экземплярами, объектами).
      @Atom могут формировать любые runtime-графы, включая циклы — это не нарушает ацикличность DAG типов.
      @Form описывает структуру @Atom, но не диктует, как @Atom взаимодействуют во время исполнения.
    Reason:
      Убирает путаницу между compile-time зависимостями типов и runtime-связями экземпляров.
      В ООП аналог: классы могут иметь unidirectional зависимости (наследование), но объекты — bidirectional ссылки.
  }

  form-atom_dualism: @Statement(~0.9) {
    Core:
      Определения @Form и @Atom имеют смысл в паре, устанавливая отношения вида "тип-сущность"
    Reason:
      Дуализм имеет аналоги в разных предметных областях: "Класс/Объект" или "Интерфейс/Реализация" или "Шаблон/Инстанс шаблона" или "type/value"
  }

  properties_of_definitions: @Statement(~0.8) {
    Core:
      Разрешена вложенность: @Atom более высокого уровня абстракции может содержать множество @Atom разных @Form более низкого уровня
      Единственность @Form: @Atom имеет одну и только одну @Form
    Reason:
      Закрепление понимания определений и выявление важнейших свойств
  }

  properties_of_AB-BA: @Statement(~0.8) {
    Core:
      Правило &AB-BA не зависит от уровней системы: действует на зависимости @Form как внутри слоя, так и между слоями
      Частный случай правила: если система S знает о какой-либо своей части A, то части A запрещено знать о системе S
      DAG-тяготение: любая совокупность @Form представима в виде DAG (Directed Acyclic Graph)
      Правило Третьего: если @Atom двух различных @Form взаимно нуждаются в данных друг друга, это указывает на рождение новой @Form
    Reason:
      Обобщение практического опыта архитектуры программного обеспечения, где двусторонние зависимости приводят к росту технического долга
  }

  sometimes_forms_are_atoms: @Statement(~0.2) {
    Core: Формы иногда могут быть представлны как Атомы некоей МетаФормы
    Reason: Постоянно проявляется на практике как удобство: тут и там видятся мета-классы
  }
}


