// explains "Knowledge Quantization Model" (KQM) knowledge fixation method
// Определяет понятия артефактов знания и содержит описания и предписания об их структуре, содержании и связях
// фвктически, KQM говорит "как записывать знания в файлы, но не говорит что с этими знаниями потом делать"
// формально, KQM — грамматика фиксации знания, но не его судьба.
// практически, KQM — Форма артефактов труда

#using namespace FAL(file: "core/FAL.tome")
#using namespace FTA(file: "core/FTA.tome")

namespace KQM {

  Reference: @Definition {
    Clause:
      Reference — нотационное средство адресации артефактов и форм (типов), определённых в корпусе томов.
      Запись &A означает конкретный артефакт (экземпляр) с именем A.
      Запись @D означает форму (тип), введённую определением D.
      Ссылки всегда пишутся без квалификации namespace: доступ к внешним namespace обеспечивается директивами #using.
    Notation:
      &<artifact_name>
      @<definition_name>
    Examples:
      &some_statement_example, @SomeDefinition,
  }

  Artifact: @Definition(@Atom) {
    Clause:
      Артефакт — персистентно зафиксированный результат интеллектуальной или практической деятельности,
      сохраняемый вне текущего контекста исполнения для последующего использования.
      В общем случае может использовать любые формы хранения, включая традиционные форматы.
      В контексте методологии KQM артефакт может быть представлен в специализированных формах
      для семантической организации и управления знаниями (@Statement, @Rule, @Task и др.).
      KQM-формы артефактов обеспечивают структурированную фиксацию с метаданными для трассировки и управления.
    Examples:
      Базы данных, документация, спецификации, чертежи, модели данных, фрагменты кода, compiled binary.
      В KQM-контексте: @Statement, @Rule, @Task, @Record, тома знаний.
  }

  Definition: @Definition(@Artifact) {
    Clause:
      Definition вводит новую @Form и фиксирует её смысл в томе.
      Определение задаёт "тип определяемого" (форму) и наполняет её содержанием (Clause/Notation/Examples).

      Локальные смыслы полей:
      - Clause: смысл вводимой формы
      - Notation: каноническая нотация/сигнатура (если применимо)
      - Examples: синтетические примеры объявлений/экземпляров
    Notation:
      <Имя>: @Definition[(<форма экземаляров Имя>)] { Clause: <clause>, [Notation: <notation>], Examples: <examples> }
    Examples:
      "MyForm: @Definition(@MyBase) { ... } // MyForm — частный случай MyBase"
      "MyContainerForm: @Definition(@MyOp(@MyElementForm)) { ... } // MyContainerForm — частный случай @MyOp(@MyElementForm)"
  }  

  Statement: @Definition(@Artifact) {
  Clause:
    Statement фиксирует фрагменты знаний в виде утверждений.
    Это частный случай @Artifact: структурная единица квантизации знания с локальной оценкой качества.
    Локальные смыслы полей:
    - Core: содержание утверждения
    - Reason: причина появления утверждения (не следствие и не "объяснение")
  Notation:
    <statement_name>: @Statement(~<quality>) { Core: <core>, Reason: <reason> }
    <statement_name>: @Statement(inf) { Core: <core>, Reason: <reason> }
    <quality> ∈ [0.0..1.0]
  Examples:
    "FALIsUsed", "ProjectNeedsMoreUnitTests"
  }

  Rule: @Definition(@Artifact) {
    Clause:
      Rule фиксирует предписания (как "должно быть") в виде индексируемого дерева строк.
      Каждая строка имеет локальный индекс; вложенность задаётся отступом; ссылка на строку задаётся путём "<id>.<id>[.<id>...]".
      В отличие от @Statement, Rule не требует Core/Reason полей: тело — это (опциональный) пролог и дерево индексируемых строк.
    Notation:
      <rule_name>: @Rule {
        <prologue_text>
        <id>: <rule_text>
          <id>: <rule_text>
            <id>: <rule_text>
        <id>: <rule_text> (ref: <id>.<id>[.<id>...])
      }
    Examples:
      "include_order"
      "codegen_dependency_rules"
  }

  Process: @Definition(@Artifact) {
    Clause:
      Process фиксирует преобразование/деятельность как артефакт: зачем (интент), что на входе/выходе, и по каким условиям
      результат считается достигнутым/корректным.
      Process не обязан фиксировать алгоритм или последовательность шагов.
  }

  Tome: @Definition(@Container(@Artifact)) {
    Clause:
      Том является коллекцией @Artifact, объединённых общим смыслом.
      Технически, том сам является артефактом и хранится в отдельном файле.
      Имя тома образует namespace для артефактов, объявленных внутри него.
      Зависимости тома (импорт других томов) фиксируются директивами #using
    Notation:
      // file: "<tome_name>.tome"
      [#using namespace <other_namespace>(file: "<path>.tome")]
      namespace <tome_name> { <artifact_declarations> }
    Examples:
      &FAL "FAL.tome", "KQM.tome", "synthesis.tome", "formats.tome"
  }

  statement_naming_rules: @Rule {
    Правила хорошего тона для именования @Statement в KQM.
    Под именем понимается токен слева от двоеточия: <statement_name>: @Statement(...)
    Имя нужно для ссылок и навигации по корпусу и не должно тащить лишнюю семантику.
    1: Имя — строка на английском без пробелов и специальных символов (разрешены только буквы, цифры, _).
    2: Имя не должно содержать явного указания на свой тип (например, "Statement", "Fact", "Rule").
    3: Одно имя — одна мысль: не объединять несколько разных утверждений под одним именем.
    4: Предпочитать короткие, но специфичные имена; избегать "SomeThing", "Temp", "Test" без необходимости.
    5: Имя не должно дублировать контекст объявления (namespace/том): не добавлять префиксы/суффиксы с ним.
  }

  some_statements_are_temporary: @Statement(~0.1) {
    Core: Some statements are "weak" and not so important in large contexts
    Reason: User needs some place/Form to write notes at least
  }

  reference_namespace_syntax: @Statement(~0.5) {
    Core:
      Ссылки пишутся без квалификации namespace: @definition_name или &artifact_name.
      Для доступа к артефактам/формам из других томов используется #using namespace <N>(file: "..."),
      после чего имена из N доступны напрямую.
    Reason:
      Убирает шум квалификации namespace и делает ссылки проще для чтения и генерации LLM.
  }

  reasons_as_causes: @Statement(~0.8) {
    Core:
      Reason каждого Statement содержит ПРИЧИНУ его появления, а не обьяснение самого утверждения или назначение
      Reason отвечает на вопрос "почему этот statement был создан?" - описывает проблему или наблюдение
    Reason:
      Reason как причина (не следствие) обеспечивает traceability создания знаний и предотвращает путаницу в назначении
  }

  noun_based_definitions: @Statement(~0.6) {
    Core:
      Definitions should use single noun words whenever possible.
      Each definition introduces one primary concept through a substantive term.
    Reason:
      Single noun definitions enhance clarity, memorability and semantic precision.
      They create stable cognitive anchors and reduce interpretive ambiguity in knowledge systems.
  }
}
