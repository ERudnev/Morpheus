// explains "Knowledge Quantization Model" (KQM) knowledge fixation method
// Определяет понятия артефактов знания и содержит утверждения об их структуре, содержании и структурных связях
// фвктически, KQM говорит "как записывать знания в файлы, но не говорит что с этими знаниями потом делать"
// формально, KQM — грамматика фиксации знания, но не его судьба.
// практически, KQM — Форма артефактов труда

#using namespace FAL(file: "core/FAL.tome")
#using namespace FTA(file: "core/FTA.tome")

namespace KQM {

  Reference: @Definition {
    Clause:
      Reference — нотационное средство адресации артефактов и форм (типов), определённых в корпусе томов.
      Запись &A означает конкретный артефакт (экземпляр) с именем A.
      Запись @D означает форму (тип), введённую определением D.
      Ссылки всегда пишутся без квалификации namespace: доступ к внешним namespace обеспечивается директивами #using.
    Notation:
      &<artifact_name>
      @<definition_name>
    Examples:
      &some_statement_example, @SomeDefinition,
  }

  Artifact: @Definition(@Atom) {
    Clause:
      Артефакт — персистентно зафиксированный результат интеллектуальной или практической деятельности,
      сохраняемый вне текущего контекста исполнения для последующего использования.
      В общем случае может использовать любые формы хранения, включая традиционные форматы.
      В контексте методологии KQM артефакт может быть представлен в специализированных формах
      для семантической организации и управления знаниями (@Statement, @Task и др.).
      KQM-формы артефактов обеспечивают структурированную фиксацию с метаданными для трассировки и управления.
    Examples:
      Базы данных, документация, спецификации, чертежи, модели данных, фрагменты кода, compiled binary.
      В KQM-контексте: @Statement, @Task, @Record, тома знаний.
  }

  Definition: @Definition(@Artifact) {
    Clause:
      Definition вводит новую @Form и фиксирует её смысл в томе.
      Определение задаёт "тип определяемого" (форму) и наполняет её содержанием (Clause/Notation/Examples).

      Локальные смыслы полей:
      - Clause: смысл вводимой формы
      - Notation: каноническая нотация/сигнатура (если применимо)
      - Examples: синтетические примеры объявлений/экземпляров
    Notation:
      <Имя>: @Definition[(<форма экземаляров Имя>)] { Clause: <clause>, [Notation: <notation>], Examples: <examples> }
    Examples:
      "MyForm: @Definition(@MyBase) { ... } // MyForm — частный случай MyBase"
      "MyContainerForm: @Definition(@MyOp(@MyElementForm)) { ... } // MyContainerForm — частный случай @MyOp(@MyElementForm)"
  }  

  Statement: @Definition(@Artifact) {
  Clause:
    Statement фиксирует фрагменты знаний в виде утверждений.
    Это частный случай @Artifact: структурная единица квантизации знания с локальной оценкой качества.
    Локальные смыслы полей:
    - Core: содержание утверждения
    - Reason: причина появления утверждения (не следствие и не "объяснение")
  Notation:
    <statement_name>: @Statement(~<quality>) { Core: <core>, Reason: <reason> }
    <statement_name>: @Statement(inf) { Core: <core>, Reason: <reason> }
    <quality> ∈ [0.0..1.0]
  Examples:
    "FALIsUsed", "ProjectNeedsMoreUnitTests"
  }

  Tome: @Definition(@Container(@Artifact)) {
    Clause:
      Том является коллекцией @Artifact, объединённых общим смыслом.
      Технически, том сам является артефактом и хранится в отдельном файле.
      Имя тома образует namespace для артефактов, объявленных внутри него.
      Зависимости тома (импорт других томов) фиксируются директивами #using
    Notation:
      // file: "<tome_name>.tome"
      [#using namespace <other_namespace>(file: "<path>.tome")]
      namespace <tome_name> { <artifact_declarations> }
    Examples:
      &FAL "FAL.tome", "KQM.tome", "synthesis.tome", "formats.tome"
  }

  some_statements_are_temporary: @Statement(~0.1) {
    Core: Some statements are "weak" and not so important in large contexts
    Reason: User needs some place/Form to write notes at least
  }

  fact_naming_convention: @Statement(~0.5) {
    Core:
      Имена @Atom в @Form "Statement" - строки на Английском без пробелов и специальных символов.
      Допустимы только буквы, цифры и знак подчеркивания.
      Имя факта не должно содержать даже в мягкой форме указание на его тип (минимум тавтологии).
    Reason:
      Такая форма имен весьма удобна при сементическом связывании, чиста и человеко-читаема
  }

  reference_namespace_syntax: @Statement(~0.5) {
    Core:
      Ссылки пишутся без квалификации namespace: @definition_name или &artifact_name.
      Для доступа к артефактам/формам из других томов используется #using namespace <N>(file: "..."),
      после чего имена из N доступны напрямую.
    Reason:
      Убирает шум квалификации namespace и делает ссылки проще для чтения и генерации LLM.
  }

  reasons_as_causes: @Statement(~0.8) {
    Core:
      Reason каждого Statement содержит ПРИЧИНУ его появления, а не обьяснение самого утверждения или назначение
      Reason отвечает на вопрос "почему этот statement был создан?" - описывает проблему или наблюдение
    Reason:
      Reason как причина (не следствие) обеспечивает traceability создания знаний и предотвращает путаницу в назначении
  }

  noun_based_definitions: @Statement(~0.6) {
    Core:
      Definitions should use single noun words whenever possible.
      Each definition introduces one primary concept through a substantive term.
    Reason:
      Single noun definitions enhance clarity, memorability and semantic precision.
      They create stable cognitive anchors and reduce interpretive ambiguity in knowledge systems.
  }
}
