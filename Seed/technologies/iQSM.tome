#include "FAL.tome"

@KQM::Tome "iQSM" {
    Description:
        Описание технологии (immutable)Quantized State Model, систематизация понимания этой технологии.
        Так как iQSM развивается и была очень близкой в начале развития с достаточно известной и понятной
        концепцией ECS (Entity Component System), данный том содержит как отсылки к ECS, сравнения с ней
        и даже немного осмысления самой ECS для контекста

    Facts {
        @KQM::Fact "Model" {
            Q: 0.9
            Core:
                Форма описывающая структуру моделируемой с помощью iQSM части предметной области
                @Model имеет внутри строго определенный список (типов) @Aspect, а зависимости между Аспектами (как типами) определены в самих Аспектах
                Считается, что  Модель "не знает" о конкретных типах Аспектов внутри нее, формально это обезличенный гомогенный список абстрактных типов.
                Все Аспекты модели можно представить в виде Direct Acyclic Graph, удовлетворяющему условию &FAL::AB-BA для любой пары (типов) @Aspect внутри графа
            Reason:
                выполнение критерия &FAL::AB-BA для "Модель - Конкретный Тип Аспекта" требовало от реализации технических трюков, но позволило гарантировать чистоту связей между типами
                исторически понятие "Модели" формировалось при решении задач управления "состояниями программы", что потребовало термина
        }

        @KQM::Fact "State" {
            Q: 0.9
            Core: Термин, обозначающий "экземпляр состояния нашей программы" или @FAL::Atom её Model
            Reason: Model - тип, State - экземпляр всех данных логики программы.
        }

        @KQM::Fact "Identifier<Aspect>" {
          Q: 0.9
          Core:
            @FAL::MetaForm, создающий Формы (типы) идентификоторов для @Item
            Пространство типов индексов не изоморфно пространству типов @Aspect: одни Аспекты имеют "свой" тип идентификатора,
            другие Аспекты "пользуются" типом определенным в другом Аспекте. 
            Для Аспекта известна Форма (&FAL::Form) ссылки на любой Item данного аспекта: Aspect::Id
            Этот тип может быть либо определен внутри Аспекта либо указан для Аспекта как тип Id другого Аспекта
          Reason:
            удобно для реализации и понимания: У Аспекта есть свой тип Id для Item и не всегда важно, это собственный тип или чужой.
            оригинальный ECS в этих терминах имел единственный оригинальный тип Id (EntityId) и все возможные типы
            Компонент "якорились" на единственный тип Entity. Создание разных типов Id в iQSM увело систему от единого Entity как типа
        }

        @KQM::Fact "Item" {
            Q: 0.9
            Core:
                &FAL::Atom, неделимая часть любого состояния системы. Экземпляр 
                Для каждого @Aspect есть только одна Форма для всех его Item
                Говоря о "типе Item" имеем в виду Аспект, в котором задана Форма этого Item
            Reason:
                проэволюционировавшие Component (as Object) из ECS
                Удобно говорить "этот Итем имеет тип X"
        }

        @KQM::Fact "Aspect" {
            Q: 0.9
            Core:
                Аспект, это Форма (@FAL::Form), группирующая набор форм (локальных типов) одного класса сущностей предметной области:
                - @Aspect::Item - Внутренняя Форма для элементов данных Аспекта (какого вида данные)
                - Инстанцирует мета-форму @Table как форму @Table<Aspect> (как хранятся данные)
                - @Aspect::Id как Форма или алиас Формы (как адресуются данные)
                - Набор односторонних связей с другими (типами) Аспектами (как и любая связь между типами &iQSM, подвержено требованию &FAL::AB-BA)
                - Набор операций с Item этого Аспекта
                - Набор функций Валидации для @Aspect::Item и @Table<Aspect> как часть Формы Аспекта
                - Набор методов Валидации, как обязательно применяющихся к Item операций
            Reason:
                Решается две проблемы:
                - семантическая неоднозначность термина ECS "Component" (в ECS не всегда понятно: то ли речь про классы, то ли про объекты этих классов)
                - обобщаются ECS "Entity" и "Component" как единая форма "элементов"
                - удобство: считать что для каждого Aspect A однозначно определены A::Id, A::Item, A::Operations, e.t.c
        }

        @KQM::Fact "Table" {
            Q: 0.9
            Core:
                Table является @FAL::MetaForm
                Table<X> ~= @FAL::Form где атомы - связи вида { Атом Формы Aspect<X>::Id -> Атом Формы Aspect<X>::Item }
                Технически, Table<MyAspect> == ассоциативный контейнер MyAspect::Item по ключу MyAspect::Id
            Reason:
                Table по сути является аналогом состояния ECS System.
        }

        @KQM::Fact "Functor" {
            Q: 0.5
            Core: Термин Functor технический, обобщение &Operator и &Validator
            Reason: удобство конструирования терминов
        }

        @KQM::Fact "Operator" {
            Q: 0.9
            Core:
                Частный случай @Functor, как Логическая операция с Моделью вида "foo(State, Aspect::Id, Args..)->{new State, Result...}"
                Некая логическая или инфраструктурная операция, принимающая на входе State (и доп аргументы)
                и создающая новый State.
                В узком смысле, Операции привязаны к Аспектам, но это удобство а не обязательство
                Любая операция, которая хочет создать новое состояние чего угодно, приводит в итоге к новому State
            Reason:
                На практике Операции удобно определять внутри Аспектов как внутреннюю Форму (тип) в Aspect<X>
                для элементарных операций над Атомами (Aspect<X>::Item) или над Таблицами (Aspect<X>::Table)
        }

        @KQM::Fact "Validator" {
            Q: 0.9
            Core:
                Частный случай &Functor со своим смыслом и особенностями:
                - Выполняют контракт "сделать Item/Table правильным с их точки зрения"
                - Вызываются всем скопом автоматически в конце логических операций (после действия Операторов)
                - Их нет смысла вызывать вручную
                - Не знают вообще о любых других операторах и валидаторах, максимально атомарны
                - могут противоречить друг другу и эти противоречия могут быть неустранимы на уровне исполнения
            Reason:
                С недостатками, вроде неустранимости приходится жить, формируя стратегии валидации, но очень важно
                оставлять Валидации как можно более простыми. Это помогает там, где системы становятся сложными:
                стратегически выгоднее избегать сложных операций Валидации путем сложности всего процесса Валидации
        }

        @KQM::Fact "StateHolder" {
            Q: 0.9
            Core:
                Семейство классов Мутабельных объектов, предназначенных для временного держания состояний всей Модели
                или ее частей. Частью @Model быть не может, но полезен рядом с моделью. Вариантов использования много,
                от локальной группировки изменений и отдачи в виде единого, до "истории" стейтов всей модели.
            Reason:
                Некий "мост" между по природе мутабельными языками и иммутабельной логикой iQSM
                На практике мутабельность обычно локализуется в инфраструктурных держателях состояний.
        }

        @KQM::Fact "AspectList" {
            Q: 0.8
            Core: Некий Scope, набор неповторяющихся Аспектов (типов) из Модели. Удобно рассматривать в виде DAG
            Reason: В разных задачах речь заходит о "списке типов" и термин оказался удобным на практике.
        }

        @KQM::Fact "Basis" {
            Q: 0.6
            Core: Единственный и полный @AspectList всех известных Модели Аспектов.
            Reason: Для реализации бывает удобно привязывать всю мета-информацию именно к Базису
        }

        @KQM::Fact "FALUnifiesOOPAndECS" {
            Q: 0.85
            Core:
                The Form-Atom language &FAL can describe OOP, ECS, and iQSM uniformly.
                Paradigm-specific terms become projections of the same structure.
            Reason: A common language reduces accidental complexity between architectural models.
        }

        @KQM::Fact "iQSMLooksAsRepository" {
            Q: 0.3 // illustrative analogy
            Core:
                Иногда iQSM и работа с ним становится похожей на работу с "репозиторием состояний системы"
                И многие термины iQSM очень похожи на сущности (процессы) в Git
            Reason: появляется много аналогий - коммиты, ветки, Merge и даже что-то аналогичное Git Flow
        }

        @KQM::Fact "WhyItIsNotEcs" {
            Q: 0.3
            Core:
                Все три слова из Entity Component System потеряли свой смысл для iQSM:
                - "Entity" перестал быть классом в iQSM, стал признаком Аспекта - способности Атомов существовать самостоятельно
                - "Component" переосмыслен в iQSM из-за путаницы "класс-объект" и "одно состояние - множество состояний одного элемента"
                - "System" перестали быть отдельной сущностью для iQSM, растворившись среди операций, определенных в Аспектах и Аспектов, определенных для операций над другими аспектами
            Reason:
                Оставаясь близким родсвенником ECS, iQSM говорит на другом языке ради семантической строгости
        }

        @KQM::Fact "ImmutabilityOfAtoms" {
            Q: 0.95
            Core: Атомы (Item) iQSM и сам ее State иммутабельны
            Reason: иммутабельность введена в iQSM как выбранный механизм операций с состояниями
        }

        @KQM::Fact "ImmutabilityIsConceptual" {
            Q: 0.9
            Core:
                Иммутабельность State — это концептуальный инвариант, гарантирующий отсутствие side effects и чистоту операций.
                Физическая реализация может использовать sharing (например, структурное sharing в persistent data structures) для минимизации копирования.
                State — это логический снимок, а не физическая копия данных; изменения затрагивают только измененные части.
            Reason:
                Устраняет страх overhead: иммутабельность — не про копирование всего, а про неизменность прошлого состояния.
                Позволяет ветвление и concurrency без race conditions, сохраняя эффективность.
        }

        @KQM::Fact "RuntimeCyclesAllowed" {
            Q: 0.9
            Core:
                По правилам iQSM циклы между типами Aspect'ов недопустимы. Атомы же (Item) в State могут свободно ссылаться друг на друга циклически.
                Например, Aspect A может ссылаться на Aspect B (A → B), но не наоборот (нет B → A)
                При этом Item из A и Item из B могут иметь взаимные ссылки черед идентификаторы (экземпляров) друг друга
            Reason:
                Помогает избежать взаимных зависимостей между типами, не ограничивая связи между объектами
        }

        @KQM::Fact "AspectIdentifierMapping" {
            Q: 0.9
            Core:
                Каждый @Aspect имеет единственный определенный для него тип @Identifier.
                Не каждый тип @Identifier имеет единственный @Aspect - один тип идентификатора может использоваться несколькими аспектами.
                Это отношение является сюръекцией: аспекты → типы идентификаторов.
            Reason:
                Использовано как механизм ухода от Entities к "классическим" ECS: Аспекты со "своим родным" Id эквивалентны ECS::Entity,
                Аспекты "пользующиеся чужими" типами идентификаторов - аналог ECS::Component
        }

        @KQM::Fact "StateIsLightWeight" {
            Q: 0.6 // пояснение
            Core:
                На уровне концепции "Стейт это состояние системы". Реализация сильно оптимизирует и копирование
                и создание нового стейта из старого.
            Reason:
                Иммутабельные State часто реализуются через структурное разделение; это качественно снижает
                накладные расходы по сравнению с полным копированием
        }

        @KQM::Fact "ModelStateDualism" {
            Q: 0.95
            Core: Пара Модель-Стейт является проявлением &FAL::ForAtomDualism. Можно говорить о "стейтах модели"
            Reason: удобная терминология
        }

        @KQM::Fact "ItemIsNotAnObject" {
            Q: 0.8
            Core:
                Item это лишь одно из состояний. Если попытаться найти в iQSM аналог Объекта в ООП,
                это это будет совокупность всех известных @Item с одинаковым Id среди всех State Модели.
                Концептуально - Объекты в iQSM есть, но размазаны по всем известным состояниям, связываясь в единое
                целое через общее значение Id
            Reason:
                что бы объяснить похо владющему концептом "иммутабельность" программисту "где же у на объекты?" приходится
                рассказывать, что "объект это сумма всех иммутабельных состояний. Именно по-этому и нет смысла в указателях на обьекты
        }

        @KQM::Fact "StateIsLikeAnItem" {
            Q: 0.8
            Core:
                Аналогично &ItemIsNotAnObject State есть Атом, единичное состояние Программы.
                Аналогично набору Item с равными значениями Id, множество State "записывает" эволюцию состояния снепшотами
                Совсем не обязательно считать эволюцию "линией" это может быть более сложная структура
            Reason:
                улучшает понимание иммутабельных особенностей iQSM
        }

        @KQM::Fact "AspectNameMatters" {
            Q: 0.2
            Core:
                Каждый Аспект (как Форма и структура Форм) имеет имя (строка) которое очень
                удобно для связывания между формами разных уровней (Аспект имеет подтипы)
            Reason:
                По смыслу, Апект это скорее пространство имен, но в С++ реализации очень удобно ситать типом и использовать как параметр шаблонов:
                - template<Aspect X> get_item()-> typename X::Item
                - template<Aspect X> struct Table<X> {...} ~= continer<X::Id, X::Item>
        }

        @KQM::Fact "OwnIdentifierMeans" {
            Q: 0.85
            Core:
                Item тех Аспектов, где свой Id определен - могут существовать самостоятельно
                Item тех Аспектов, где как Id использован "чужой" тип, жизненный цикл
                "привязывается" к Item того типа (Аспекта), чем тип Id использован
            Reason:
                Обобщение ECS Entity, как "контролера жизненного цикла компонент" на "Аспект с собственным типом Id"
                Принцип "эти объекты самостоятельны, а другие - их опциональные логические части"
        }

        @KQM::Fact "FunctorLooksBetterWithTable" {
            Q: 0.5
            Core: удобнее определять конкретные Функторы как Атомы некоей Формы "операций над Table"
            Reason: Реализация сильно проще
        }

        @KQM::Fact "StructuralValidator" {
            Q: 0.5
            Core:
                Частный случай @Validator, поддерживающий структуру Модели и выводимый из определений Аспектов Модели.
            Reason:
                иногда удобно говорить отдельно об "логических" и "структурных" валидаторов, разделяя правила структуры от логики
          }

        @KQM::Fact "Validation" {
            Q: 0.9
            Core:
              Не Форма и не Атом а некий формат процесса применения всех нужных Валидаторов над State или его частями
              Validation(State) -> State
            Reason:
              Множество Валидаторов имеет смысл рассматривать как части некоего единого процесса, обеспечивающего корректность состояний Модели 
          }

        @KQM::Fact "ValidationIsSubjective" {
            Q: 0.9
            Core:
                Элемент Aspect<A>::Item валидный с точки зрения критериев Aspect<A>::Validation, может считаться невалидным
                с точки зрения Aspect<B>::Validation при чем из &FAL::AB-BA следует что раз B меет "точку зрения про A"
                значит Aspect<A> вообще не знает о существовании Aspect<B>
            Reason:
                Валидность зависит от контекста, плная валидность для всех Table Стейта может быть достигнута валидацией
                по дереву зависимостей внутри полного DAG Аспектов (как типов)
        }

        @KQM::Fact "WhyFunctorApplicationCanCreateState" {
            Q: 0.1 // обьяснение
            Core:
                В общем случае, применение Функтора может создавать новый Стейт
            Reason:
                Измененный Item не запишешь в Table - он иммутабельный, надо создать новый..
                Table, но его не запишешь в State - он иммутабельный, надо создать новый...
                State, и его уже можно где-то запомнить в StateHolder или передать как аргумент...
                следующему оператору
        }

        @KQM::Fact "WhyFunctorApplicationCanSkipCreatingState" {
            Q: 0.1 // обьяснение
            Core:
                В общем случае, применение Функтора может не создавать новый Стейт:
                - функтор может быть изначально "чисто для чтения либо рассчетов" ("константный")
                - функтор мжет иметь роль "менять что-то" но при конкретном вызове "не захотеть"
            Reason:
                Если Оператор ничего не поменял, то и Стейт создавать не надо.
                Когда Валидаторы молчат и ничего не трогают, так и незачем плодить Стейты.
                Оптимизация.
        }

        @KQM::Fact "TimeNotMatters" {
            Q: 0.2
            Core:
                State may be interpreted as a snapshot; mapping to time is optional and external to the model
            Reason:
                Можно иметь несколько конкурирующих "веток" и смержить их когда надо.
                Можно выбрамывать все состояния, оставляя одно "текущее". Выбор за архитектором конкретной системы.
        }

        @KQM::Fact "Change" {
            Q: 0.9
            Core:
                Некая Форма, атомы которой хранят изменение State относительно другого
                &Functor допустимо (и рекомендуется) задавать в виде "результ работы - Change"
            Reason:
                Change Концептуально не является необходимым но очень упрощает реализацию и важен для понимания
        }

        @KQM::Fact "ApplyChange" {
            Q: 0.8
            Core: Некий процесс при котором Apply(State, Change) -> State
            Reason: удобно говорить в таких терминах
        }

        @KQM::Fact "Merge" {
            Q: 0.9
            Core:
                Процесс, при котором несколько стейтов формируют один совместный по заранее известным правилам.
            Reason:
                Термин всплывает при использовании iQSM и просочился в базовые определения
        }

        @KQM::Fact "StrongTypedOrigin" {
            Q: 0.2
            Core:
                Концепция iQSM по своей природе не зависит от языка программирования.
                Однако она использует строгую типизацию, естественную для языков проде С++
            Reason:
                Это объясняет акцент на строгой типизации, одновременно признавая более широкую применимость концепции.
        }

        @KQM::Fact "SystemIsStateCentric" {
            Q: 0.9
            Core:
                iQSM организована вокруг явных состояний мира.
                Состояние является значением первого класса и представляет полный снимок.
            Reason:
                Это устанавливает состояние как первичный носитель смысла и времени.
        }

        @KQM::Fact "StateIsImmutable" {
            Q: 0.5
            Core:
                Любое изменение производит новое состояние.
                Предыдущие состояния никогда не мутируют.
            Reason:
                Неизменяемость устраняет скрытые побочные эффекты и позволяет ветвление.
        }

        @KQM::Fact "NoCentralEntity" {
            Q: 0.5
            Core:
                Не существует универсального якоря Entity.
                Идентичность не сводится к единому корневому идентификатору.
            Reason:
                Это устраняет онтологическое узкое место классического ECS.
        }

        @KQM::Fact "ElementsAreIndependent" {
            Q: 0.85
            Core:
                Некоторые элементы существуют независимо со своей собственной идентичностью.
                Они не прикреплены к родительской сущности.
            Reason:
                Это позволяет создавать более богатые графы идентичности, чем плоские модели сущность-компонент.
        }

        @KQM::Fact "OperationsAreExternal" {
            Q: 0.95
            Core: Операции не принадлежат данным. Они преобразуют состояние извне.
            Reason: Разделение структуры и поведения сохраняет архитектурную ясность.
        }

        @KQM::Fact "OperationsProduceStates" {
            Q: 0.95
            Core: Операция отображает одно состояние в другое. Результатом является новое состояние.
            Reason: Это делает временную эволюцию явной и поддающейся инспекции.
        }

        @KQM::Fact "ValidationIsSeparated" {
            Q: 0.9
            Core:
                Валидация не смешивается с логикой трансформации.
                Нормализация и проверки целостности являются отдельными шагами.
            Reason:
                Не будь Валидация отдельным и обязательным шагом в конце любой операции,
                мы бы получали промежуточные невалидные стейты, которые просто нет смысла делать стабильными
        }

        @KQM::Fact "TypeGraphIsAcyclic" {
            Q: 0.95
            Core: By construction, the type dependency graph is acyclic within the modeling rules.
            Reason: Ацикличность графа типов используется как средство повышения модульности
        }

        @KQM::Fact "StructuralDecompositionByDAG" {
            Q: 0.9
            Core:
                Система может быть разрезана вдоль DAG типов.
                Частичные представления остаются структурно валидными.
            Reason:
                Структура DAG обеспечивает безопасное извлечение подсистем.
        }

        @KQM::Fact "ReadingIsPure" {
            Q: 0.95
            Core:
                Операции чтения не модифицируют состояние.
                Они наблюдают только существующую структуру.
            Reason:
                Чистота гарантирует референциальную прозрачность для запросов.
        }

        @KQM::Fact "WritingIsExplicit" {
            Q: 0.95
            Core:
                Операции записи являются явными трансформациями.
                Скрытые мутации не существуют.
            Reason:
                Явные записи делают распространение изменений анализируемым.
        }

        @KQM::Fact "TimeIsModeledByStates" {
            Q: 0.9
            Core:
                Время представляется как последовательность состояний.
                Не существует неявного временного измерения.
            Reason:
                Временное рассуждение возникает из последовательности состояний.
        }

        @KQM::Fact "SystemIsLanguageForStructure" {
            Q: 0.85
            Core:
                iQSM выступает как декларативный язык для структуры.
                Он описывает что существует, а не как это исполняется.
            Reason:
                Это согласовывает систему с архитектурным и когнитивным моделированием.
        }

        @KQM::Fact "Resource" {
            Q: 0.9
            Core:
                Ресурс - данные вне iQSM Модели необходимые для работы, но которые решено в Модель не заносить.
                Для такого типа, например "SomeType", создается Аспект с именем SomeTypeResource.
                SomeTypeResource::Id может использоваться как идентификатор экземпляра SomeType вне iQSM модели
                SomeTypeResource::Item может содержать какую-лио информацию об экземпляре SomeType, она
                попадает в Модель, когда само тело экземпляра SomeType остается вовне в промежуточном слое (не являющемся iQSM моделью)
                этот слой, так называемый ResourceManager, предоставляет iQSM модели доступ к экземплярам SomeType по
                SomeTypeResource::Id
                Таким образом мутабельное, обычное для ООП состояние Ресурсов iQSM Модель не контролирует,
                но работает через Id "как есть"
                Это отлично работает, когда сами ресурсы константы и имеют время жизни Инстанса iQSM модели.
                Это не очень хорошо работает, когда ресурсы не константы и поведение всего этого вместе трудно предсказать
                Это прагматичный режим совместимости; мутабельные ресурсы могут увеличивать техдолг
            Reason:
                Тяжелый класс, на объекты которого надо ссылаться, читать их данные и иногда даже менять - неудобен для iQSM.
                Аналогично LFS в Git или текстурам в движке игры.
        }

        @KQM::Fact "FALused" {
            Q: 0.5 // удобство
            Core: iQSM использует язык &FAL и подчинен его правилам (&AB-BA)
            Reason: Исторически, FAL был в основе перехода ECS -> iQSM
          }
    }
}
